<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/core-tooltip/core-tooltip.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="toast-ajax/toast-ajax.html">
<link rel="import" href="search-box.html">
<link rel="import" href="tick-box.html">
<link rel="import" href="box-list.html">
<link rel="import" href="add-tick.html">

<polymer-element name="tick-list" attributes="gid canFork">
	<template>
        <link rel="stylesheet" href="../css/shared-styles.css">
		<style>
			:host {
				display: block;
			}
			h1 {
				font-size: 1.8rem;
				font-weight: 100;
				padding: 0 0 0 10px;
			}
	    </style>
		<toast-ajax
			auto
			id="tickListAPI"
			url="{{'http://urop2014.dtg.cl.cam.ac.uk/UROP_UI/api/tick/list/' + gid}}"
			handleAs="json"
			on-core-response="{{tickListResponse}}"

			popUpError
			captureError
			waitMessage="Loading ticks....">
		</toast-ajax>

		<!-- Add Tick Element -->
		<add-tick id="tickAdder" gid="{{gid}}" on-tick-added="{{tickAddedHandler}}"></add-tick>

		<!-- Tick list card header. -->
		<div id="headerBar" layout horizontal center>
			<!--<h1 flex>Ticks ({{ticks ? ticks.length : 0}})</h1>-->
            <span flex></span>
			<search-box id="searchBox" placeholder="Search..."></search-box>
            <core-tooltip label="Add Tick" class="add-tick-tooltip">
			    <paper-icon-button id="addTickButton" icon="add" on-click="{{addTickClicked}}"></paper-icon-button>
            </core-tooltip>
		</div>

		<!-- Tick list. -->
		<box-list id="list" selector on-core-select="{{selected}}" valueattr="tick">
			<template repeat="{{tickFork in tickForks | tickListFilter($.searchBox.query)}}">
				<tick-box class="itemBox" tickId="{{tick._id}}" tickName="{{tick.name}}" tick="{{tickFork.tick}}" statusCode="{{tickFork.statusCode}}"></tick-box>
			</template>
		</box-list>

	</template>
	<script>
		Polymer('tick-list', {
			tickListResponse: function () {
				var ticks = this.$.tickListAPI.response.ticks;
                var forks = this.decompressForks(this.$.tickListAPI.response.forks, ticks);
                var statusCodes = forks.map(function(fork) {
                    var mode;
                    if (fork == -1) {
                        mode = "?"; //don't show bed
                    } else {
                        if (fork.deadlinePassed) {
                            //deadline passed, so failed.
                            mode = "F";
                        } else if (!fork.reportAvailable) {
                            //Not submitted.
                            mode = "I";
                        } else if (!fork.unitPass) {
                            //Failed automated tests.
                            mode = "UF";
                        } else if (!fork.humanPass) {
                            //Passed automated tests.
                            mode = "UP";
                        } else if (fork.humanPass) {
                            //Passed by ticker
                            mode = "P";
                        } else {
                            //invalid fork object state
                            mode = "?";
                        }
                    }
                    return mode;
                });
                this.tickForks = [];

                for (var i = 0; i < ticks.length; i++) {
                    this.tickForks[i] = {tick: ticks[i], statusCode: statusCodes[i]};
                }
			},

            decompressForks: function(compressedForks, ticks) {
                //assert ticks and compressedForks are both sorted in ascending order of id

                //create a new list of fork objects
                var forks = [];

                //maintain a pointer to the position in the given fork list
                var forksPointer = 0;

                //for each element in the ticks list: if it matches the fork object at the fork pointer, insert it
                //onto new fork list, otherwise insert an empty fork
                for (var i = 0; i < ticks.length; i++) {
                    if (forksPointer > compressedForks.length - 1) {
                        forks[forks.length] = -1;
                    } else {
                        if (compressedForks[forksPointer]._id.lastIndexOf(ticks[i]._id) > -1) {
                            //we have a match
                            if (ticks[i].deadline == null) {
                                compressedForks[forksPointer].deadlinePassed = false;
                            } else {
                                var datetime = moment(ticks[i].deadline);
                                compressedForks[forksPointer].deadlinePassed = datetime < moment();
                            }
                            forks[forks.length] = compressedForks[forksPointer];
                            forksPointer++;
                        } else {
                            forks[forks.length] = -1;
                        }
                    }
                }

                return forks;
            },

            forkStatusUpdated: function(detail) {
                if (detail.statusCode == "-") {
                    return;
                }

                this.tickForks.map(function(el) {
                    if (el.tick._id == detail.tickId) {
                        el.statusCode = detail.statusCode;
                    }
                })
            },

			tickListFilter: function(items, q) {
				if (items && q) {
					return items.filter(this.tickFilter.bind(this));
				}
				return items;
			},

			tickFilter: function(item) {
				var q = this.$.searchBox.query.toLowerCase();
				return (item.tick.name.toLowerCase().indexOf(q) > -1 ||
						item.tick.author.toLowerCase().indexOf(q) > -1);
			},

			selected: function() {
				var sel = this.$.list.$.selector.selected;
				this.selectedTickId = sel._id;
				this.selectedTickIdName = sel.name;
                this.selectedTickObj = sel;

                if (this.canFork) {
                    this.forkClicked();
                }
			},

			forkClicked: function () {
				if (this.selectedTickId)
					this.fire('fork-clicked', {
						tickId: this.selectedTickId,
						tickName: this.selectedTickIdName,
                        tickObj: this.selectedTickObj
					});
			},

			tickAddedHandler: function () {
				this.$.tickListAPI.go();
			},

			addTickClicked: function () {
				this.$.tickAdder.$.dialog.toggle();
			}
		});
	</script>
</polymer-element>
